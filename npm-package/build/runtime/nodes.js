import{tokenTypeString,tt}from"../parse/tokens.js";import{ESError,InvalidSyntaxError,ReferenceError,TypeError}from"../errors.js";import{Context}from"./context.js";import{Position}from"../position.js";import{now}from"../constants.js";import{interpretArgument}from"./argument.js";import{ESArray,ESBoolean,ESFunction,ESNamespace,ESNumber,ESObject,ESPrimitive,ESString,ESType,ESUndefined,types}from"./primitiveTypes.js";import{str}from"../util/util.js";export class interpretResult{constructor(){this.val=new ESUndefined,this.shouldBreak=!1,this.shouldContinue=!1}}export class Node{constructor(t,e=!1){this.startPos=t,this.isTerminal=e}interpret(t){var e;const r=now(),n=new interpretResult,o=this.interpret_(t);o instanceof ESError?n.error=o:o instanceof interpretResult?(n.val=o.val,n.error=o.error,n.funcReturn=o.funcReturn,n.shouldBreak=o.shouldBreak,n.shouldContinue=o.shouldContinue):n.val=o,n.error&&n.error.startPos.isUnknown&&(n.error.startPos=this.startPos),n.val instanceof ESPrimitive||(n.error=new TypeError(Position.unknown,"Primitive","Native JS value",str(n.val)),n.val=new ESUndefined),(e=n.val.info).file||(e.file=this.startPos.file),Node.interprets++;let s=now()-r;return Node.totalTime+=s,s>Node.maxTime&&(Node.maxTime=s),n}}Node.interprets=0,Node.totalTime=0,Node.maxTime=0;export class N_binOp extends Node{constructor(t,e,r,n){super(t),this.left=e,this.opTok=r,this.right=n}interpret_(t){const e=this.left.interpret(t);if(e.error)return e.error;const r=this.right.interpret(t);if(r.error)return r.error;const n=e.val,o=r.val;if(void 0===n)return new TypeError(this.opTok.startPos,"~undefined","undefined",n,"N_binOp.interpret_");if(void 0===o)return new TypeError(this.opTok.startPos,"~undefined","undefined",o,"N_binOp.interpret_");function s(e,r,n,o){if(!(e instanceof ESPrimitive&&r instanceof ESPrimitive&&e.hasProperty({context:t},new ESString(n))))return new TypeError(o,"unknown",null==e?void 0:e.typeOf().valueOf(),null==e?void 0:e.valueOf(),`Unsupported operand for ${n}`);const s=e.__getProperty__({context:t},new ESString(n));if(!(s instanceof ESFunction))return new ESError(o,"TypeError",`_Unsupported operand ${n} on type ${e.typeOf().valueOf()} | .${n}=${str(s)}`);const i=s.__call__({context:t},r);return i instanceof ESPrimitive?i:new ESError(o,"TypeError",`__Unsupported operand ${n} on type ${e.typeOf().valueOf()}`)}switch(this.opTok.type){case tt.LTE:{const t=s(n,o,"__lt__",this.opTok.startPos),e=s(n,o,"__eq__",this.opTok.startPos);return t instanceof ESError?t:e instanceof ESError?e:s(t,e,"__or__",this.opTok.startPos)}case tt.GTE:{const t=s(n,o,"__gt__",this.opTok.startPos),e=s(n,o,"__eq__",this.opTok.startPos);return t instanceof ESError?t:e instanceof ESError?e:s(t,e,"__or__",this.opTok.startPos)}case tt.NOTEQUALS:{const t=s(n,o,"__eq__",this.opTok.startPos);return t instanceof ESError?t:new ESBoolean(!t.bool().valueOf())}case tt.ADD:return s(n,o,"__add__",this.opTok.startPos);case tt.SUB:return s(n,o,"__subtract__",this.opTok.startPos);case tt.MUL:return s(n,o,"__multiply__",this.opTok.startPos);case tt.DIV:return s(n,o,"__divide__",this.opTok.startPos);case tt.POW:return s(n,o,"__pow__",this.opTok.startPos);case tt.EQUALS:return s(n,o,"__eq__",this.opTok.startPos);case tt.LT:return s(n,o,"__lt__",this.opTok.startPos);case tt.GT:return s(n,o,"__gt__",this.opTok.startPos);case tt.AND:return s(n,o,"__and__",this.opTok.startPos);case tt.OR:return s(n,o,"__or__",this.opTok.startPos);default:return new InvalidSyntaxError(this.opTok.startPos,`Invalid binary operator: ${tokenTypeString[this.opTok.type]}`)}}}export class N_unaryOp extends Node{constructor(t,e,r){super(t),this.a=e,this.opTok=r}interpret_(t){var e,r,n;const o=this.a.interpret(t);if(o.error)return o.error;switch(this.opTok.type){case tt.SUB:case tt.ADD:if(!(o.val instanceof ESNumber))return new TypeError(this.startPos,"Number",(null===(e=o.val)||void 0===e?void 0:e.typeOf().toString())||"undefined_",null===(r=o.val)||void 0===r?void 0:r.valueOf());const t=o.val.valueOf();return new ESNumber(this.opTok.type===tt.SUB?-t:Math.abs(t));case tt.NOT:return new ESBoolean(!(null===(n=null==o?void 0:o.val)||void 0===n?void 0:n.bool().valueOf()));default:return new InvalidSyntaxError(this.opTok.startPos,`Invalid unary operator: ${tokenTypeString[this.opTok.type]}`)}}}export class N_varAssign extends Node{constructor(t,e,r,n="=",o=!1,s=!1,i=!1,a=!1,l=types.any){super(t),this.value=r,this.varNameTok=e,this.isGlobal=o,this.assignType=n,this.isConstant=i,this.isDeclaration=a,this.isLocal=s,this.type=l instanceof ESType?new N_primWrapper(l):l}interpret_(t){var e,r,n,o;if(this.isDeclaration&&t.hasOwn(this.varNameTok.value))return new InvalidSyntaxError(this.startPos,`Symbol '${this.varNameTok.value}' already exists, and cannot be redeclared`);const s=this.value.interpret(t),i=this.type.interpret(t);if(s.error)return s.error;if(i.error)return i.error;if(!(i.val&&i.val instanceof ESType))return new TypeError(this.varNameTok.startPos,"Type",null!==(r=null===(e=i.val)||void 0===e?void 0:e.typeOf().valueOf())&&void 0!==r?r:"undefined",null===(n=i.val)||void 0===n?void 0:n.str(),"@ !typeRes.val || !(typeRes.val instanceof ESType)");if(!s.val)return new TypeError(this.varNameTok.startPos,"~undefined","undefined","N_varAssign.interpret_");if(!1===i.val.includesType({context:t},s.val.__type__).valueOf())return new TypeError(this.varNameTok.startPos,str(i.val),str(null===(o=s.val)||void 0===o?void 0:o.typeOf()),str(s.val));if(this.isDeclaration)return"="!==this.assignType?new InvalidSyntaxError(this.startPos,`Cannot declare variable with operator '${this.assignType}'`):(t.setOwn(this.varNameTok.value,s.val,{global:!1,isConstant:this.isConstant}),s.val);if("="===this.assignType){let e=s.val;void 0===e&&(e=new ESUndefined);const r=t.set(this.varNameTok.value,e,{global:this.isGlobal,isConstant:this.isConstant});if(r instanceof ESError)return r}else{if(this.isDeclaration)return new InvalidSyntaxError(this.startPos,`Cannot declare variable with operator '${this.assignType}'`);const e=t.get(this.varNameTok.value);if(e instanceof ESError)return e;if(null==e)return new InvalidSyntaxError(this.startPos,`Cannot declare variable with operator '${this.assignType}'`);let r,n=s.val;switch(this.assignType[0]){case"*":if(!(null==e?void 0:e.__multiply__))return new TypeError(this.startPos,"unknown",e.typeOf().valueOf(),null==e?void 0:e.valueOf(),"Unsupported operand for '*'");r=e.__multiply__({context:t},n);break;case"/":if(!(null==e?void 0:e.__divide__))return new TypeError(this.startPos,"unknown",e.typeOf().valueOf(),null==e?void 0:e.valueOf(),"Unsupported operand for '/'");r=e.__divide__({context:t},n);break;case"+":if(!(null==e?void 0:e.__add__))return new TypeError(this.startPos,"unknown",e.typeOf().valueOf(),null==e?void 0:e.valueOf(),"Unsupported operand for '+'");r=e.__add__({context:t},n);break;case"-":if(!(null==e?void 0:e.__subtract__))return new TypeError(this.startPos,"unknown",e.typeOf().valueOf(),null==e?void 0:e.valueOf(),"Unsupported operand for '-'");r=e.__subtract__({context:t},n);break;default:return new ESError(this.startPos,"AssignError",`Cannot find assignType of ${this.assignType[0]}`)}if(r instanceof ESError)return r;let o=t.set(this.varNameTok.value,r,{global:this.isGlobal,isConstant:this.isConstant});if(o instanceof ESError)return o;s.val=r}return"(anonymous)"!==s.val.info.name&&s.val.info.name||(s.val.info.name=this.varNameTok.value),s}}export class N_if extends Node{constructor(t,e,r,n){super(t),this.comparison=e,this.ifFalse=n,this.ifTrue=r}interpret_(t){var e;let r=new Context;r.parent=t;let n=new interpretResult,o=this.comparison.interpret(t);if(o.error)return o;if(null===(e=o.val)||void 0===e?void 0:e.bool().valueOf()){if(n=this.ifTrue.interpret(r),n.val=new ESUndefined,n.error)return n}else if(this.ifFalse&&(n=this.ifFalse.interpret(r),n.val=new ESUndefined,n.error))return n;return n}}export class N_while extends Node{constructor(t,e,r){super(t),this.comparison=e,this.loop=r}interpret_(t){var e,r;let n=new Context;for(n.parent=t;;){let o=this.comparison.interpret(t);if(o.error)return o;if(!(null===(r=null===(e=o.val)||void 0===e?void 0:e.bool())||void 0===r?void 0:r.valueOf()))break;let s=this.loop.interpret(n);if(s.error)return s;if(s.shouldBreak)break}return new ESUndefined}}export class N_for extends Node{constructor(t,e,r,n,o,s){super(t),this.body=e,this.array=r,this.identifier=n,this.isGlobalId=o,this.isConstId=s}interpret_(t){var e,r,n,o,s,i,a,l;let u=new Context;u.parent=t;const p=this.array.interpret(t);if(p.error)return p;if(-1===["Array","Number","Object","String","Any"].indexOf((null===(e=p.val)||void 0===e?void 0:e.typeOf().valueOf())||""))return new TypeError(this.identifier.startPos,"Array | Number | Object | String",typeof p.val+" | "+(null===(r=p.val)||void 0===r?void 0:r.typeOf()));function d(t,e,r,n,o){u.set(e,r,{global:n,isConstant:o});const s=t.interpret(u);return s.error||void 0!==s.funcReturn?s:s.shouldBreak?(s.shouldBreak=!1,"break"):void(s.shouldContinue&&(s.shouldContinue=!1))}if(p.val instanceof ESNumber||"number"==typeof(null===(n=p.val)||void 0===n?void 0:n.valueOf()))for(let t=0;t<p.val.valueOf();t++){const e=d(this.body,this.identifier.value,new ESNumber(t),this.isGlobalId,this.isConstId);if("break"===e)break;if(e&&(e.error||void 0!==e.funcReturn))return e}else if(p.val instanceof ESObject||"number"==typeof(null===(o=p.val)||void 0===o?void 0:o.valueOf())&&!Array.isArray(null===(s=p.val)||void 0===s?void 0:s.valueOf()))for(let t in null===(i=p.val)||void 0===i?void 0:i.valueOf()){const e=d(this.body,this.identifier.value,new ESString(t),this.isGlobalId,this.isConstId);if("break"===e)break;if(e&&(e.error||void 0!==e.funcReturn))return e}else{if(!(p.val instanceof ESArray||Array.isArray(null===(a=p.val)||void 0===a?void 0:a.valueOf())))return new TypeError(this.identifier.startPos,"Array | Number | Object | String",typeof p.val);for(let t of null===(l=p.val)||void 0===l?void 0:l.valueOf()){const e=d(this.body,this.identifier.value,t,this.isGlobalId,this.isConstId);if("break"===e)break;if(e&&(e.error||void 0!==e.funcReturn))return e}}return new ESUndefined}}export class N_array extends Node{constructor(t,e,r=!1){super(t),this.items=e,this.shouldClone=r}interpret_(t){let e=new interpretResult,r=[];for(let e of this.items){const n=e.interpret(t);if(n.error||void 0!==n.funcReturn)return n;if(!n.val)continue;let o=n.val;this.shouldClone&&(o=o.clone()),r.push(o)}return e.val=new ESArray(r),e}}export class N_objectLiteral extends Node{constructor(t,e){super(t),this.properties=e}interpret_(t){let e={};for(const[r,n]of this.properties){const o=n.interpret(t);if(o.error)return o.error;const s=r.interpret(t);if(s.error)return s.error;s.val&&o.val&&(e[s.val.valueOf()]=o.val)}return new ESObject(e)}}export class N_emptyObject extends Node{constructor(t){super(t)}interpret_(t){return new ESObject({})}}export class N_statements extends Node{constructor(t,e){super(t),this.items=e}interpret_(t){let e;for(let r of this.items){const n=r.interpret(t);if(n.error||void 0!==n.funcReturn||n.shouldBreak||n.shouldContinue)return n;e=n.val}return e||new ESUndefined}}export class N_functionCall extends Node{constructor(t,e,r){super(t),this.arguments=r,this.to=e}interpret_(t){let{val:e,error:r}=this.to.interpret(t);if(r)return r;if(!e)return new TypeError(this.startPos,"any","undefined",void 0,"On function call");if(!e.hasProperty({context:t},new ESString("__call__")))return new TypeError(this.startPos,"unknown",(null==e?void 0:e.typeOf().valueOf())||"unknown",null==e?void 0:e.valueOf(),"Can only () on something with __call__ property");let n=[];for(let e of this.arguments){const r=e.interpret(t);if(r.error)return r.error;r.val&&n.push(r.val)}const o=e.__getProperty__({context:t},new ESString("__call__"));if(!(o instanceof ESFunction))return new TypeError(this.startPos,"function",str(null==e?void 0:e.typeOf()),str(e),"__call__ property must be function");if("function"!=typeof o.__value__)return new TypeError(Position.unknown,"native function","es function");const s=o.__value__({context:t},...n);return s instanceof ESError?(s.traceback.push({position:this.startPos,line:`${e.info.name}(${n.map(str).join(", ")})`}),s):s instanceof ESPrimitive?s:new ESUndefined}}export class N_functionDefinition extends Node{constructor(t,e,r,n,o="(anon)",s=new ESObject,i=""){super(t),this.arguments=r,this.body=e,this.name=o,this.this_=s,this.returnType=n,this.description=i}interpret_(t){var e,r,n;let o=[];for(let e of this.arguments){const r=interpretArgument(e,t);if(r instanceof ESError)return r;o.push(r)}const s=this.returnType.interpret(t);return s.error?s.error:s.val instanceof ESType?new ESFunction(this.body,o,this.name,this.this_,s.val,t):new TypeError(this.returnType.startPos,"Type",null!==(r=null===(e=s.val)||void 0===e?void 0:e.typeOf().valueOf())&&void 0!==r?r:"<Undefined>",null===(n=s.val)||void 0===n?void 0:n.str().valueOf(),`On func '${this.name}' return type`)}}export class N_return extends Node{constructor(t,e){super(t),this.value=e}interpret_(t){const e=new interpretResult;if(void 0===this.value)return e.funcReturn=new ESUndefined,e;let r=this.value.interpret(t);return r.error?r.error:(e.funcReturn=r.val,e)}}export class N_yield extends Node{constructor(t,e){super(t),this.value=e}interpret_(t){var e;const r=new interpretResult;if(void 0===this.value)return r.funcReturn=new ESUndefined,r;let n=this.value.interpret(t);return n.error?n.error:((null===(e=n.val)||void 0===e?void 0:e.bool().valueOf())&&(r.funcReturn=n.val),r)}}export class N_indexed extends Node{constructor(t,e,r){super(t),this.base=e,this.index=r}declaredBinOp(t,e,r,n,o){if(!t.hasProperty({context:o},new ESString(r)))return new ESError(n,"TypeError",`Unsupported operand ${r} on type ${t.typeOf().valueOf()}`);const s=t.__getProperty__({context:o},new ESString(r));if(!(s instanceof ESFunction))return new ESError(n,"TypeError",`_Unsupported operand ${r} on type ${t.typeOf().valueOf()} | .${r}=${str(s)}`);const i=s.__call__({context:o},e);return i instanceof ESPrimitive?i:new ESError(n,"TypeError",`__Unsupported operand ${r} on type ${t.typeOf().valueOf()}`)}interpret_(t){var e;let r=this.base.interpret(t);if(r.error)return r;let n=this.index.interpret(t);if(n.error)return n;const o=n.val,s=r.val;if(!s||!o)return new ESUndefined;if(void 0!==this.value){let r=this.value.interpret(t);if(r.error)return r;const n=ESPrimitive.wrap(s.__getProperty__({context:t},o));let i,a=r.val;if(null!==(e=this.assignType)&&void 0!==e||(this.assignType="="),!a)return new TypeError(this.startPos,"~undefined","undefined","undefined","N_indexed.interpret_");switch(this.assignType[0]){case"*":i=this.declaredBinOp(n,a,"__multiply__",this.startPos,t);break;case"/":i=this.declaredBinOp(n,a,"__divide__",this.startPos,t);break;case"+":i=this.declaredBinOp(n,a,"__add__",this.startPos,t);break;case"-":i=this.declaredBinOp(n,a,"__subtract__",this.startPos,t);break;case"=":i=a;break;default:return new ESError(this.startPos,"AssignError",`Cannot find assignType of ${this.assignType[0]}`)}if(i instanceof ESError)return i;if(!s.__setProperty__)return new TypeError(this.startPos,"mutable","immutable",s.valueOf());const l=s.__setProperty__({context:t},o,null!=i?i:new ESUndefined);if(l instanceof ESError)return l}return s.__getProperty__({context:t},o)}}export class N_class extends Node{constructor(t,e,r,n,o="<anon class>"){super(t),this.init=n,this.methods=e,this.name=o,this.extends_=r,this.instances=[]}interpret_(t){var e,r,n;const o=[];for(let r of this.methods){const n=r.interpret(t);if(n.error)return n.error;if(!(n.val instanceof ESFunction))return new TypeError(this.startPos,"Function",(null===(e=n.val)||void 0===e?void 0:e.typeOf().valueOf())||"undefined","method on "+this.name);o.push(n.val)}let s,i;if(this.extends_){const e=this.extends_.interpret(t);if(e.error)return e.error;if(!(e.val instanceof ESType))return new TypeError(this.startPos,"Function",(null===(r=e.val)||void 0===r?void 0:r.typeOf().valueOf())||"undefined","method on "+this.name);s=e.val}if(this.init){const e=this.init.interpret(t);if(e.error)return e.error;if(!(e.val instanceof ESFunction))return new TypeError(this.startPos,"Function",(null===(n=e.val)||void 0===n?void 0:n.typeOf().valueOf())||"undefined","method on "+this.name);i=e.val}return new ESType(!1,this.name,o,s,i)}}export class N_namespace extends Node{constructor(t,e,r="(anon)",n=!1){super(t),this.name=r,this.statements=e,this.mutable=n}interpret_(t){const e=new Context;e.parent=t;const r=this.statements.interpret(e);return r.error?r:new ESNamespace(new ESString(this.name),e.getSymbolTableAsDict(),this.mutable)}}export class N_number extends Node{constructor(t,e){super(t,!0),this.a=e}interpret_(t){let e=this.a.value;if("number"!=typeof e)return new TypeError(this.startPos,"number",typeof e);const r=new interpretResult;return r.val=new ESNumber(e),r}}export class N_string extends Node{constructor(t,e){super(t,!0),this.a=e}interpret_(t){let e=this.a.value;if("string"!=typeof e)return new TypeError(this.startPos,"string",typeof e);const r=new interpretResult;return r.val=new ESString(e),r}}export class N_variable extends Node{constructor(t){super(t.startPos,!0),this.a=t}interpret_(t){if(!t.has(this.a.value))return new ReferenceError(this.a.startPos,this.a.value);let e=new interpretResult,r=t.getSymbol(this.a.value);return r?r instanceof ESError?r:(e.val=r.value,e):new ESUndefined}}export class N_undefined extends Node{constructor(t=Position.unknown){super(t,!0)}interpret_(t){const e=new interpretResult;return e.val=new ESUndefined,e}}export class N_break extends Node{constructor(t){super(t,!0)}interpret_(t){const e=new interpretResult;return e.shouldBreak=!0,e}}export class N_continue extends Node{constructor(t){super(t,!0)}interpret_(t){const e=new interpretResult;return e.shouldContinue=!0,e}}export class N_primWrapper extends Node{constructor(t,e=Position.unknown){super(e,!0),this.value=t}interpret_(t){return this.value}}