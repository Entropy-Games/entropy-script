import{initialise}from"../init.js";import{ESError,TypeError}from"../errors.js";import{Position}from"../position.js";import{ESArray,ESPrimitive,ESString,ESType,ESUndefined,types}from"./primitiveTypes.js";import{str}from"../util/util.js";export class ESSymbol{constructor(t,e,i={}){var s,n;this.clone=()=>new ESSymbol(this.value.clone(),this.identifier,{isConstant:this.isConstant,isAccessible:this.isAccessible}),this.str=()=>new ESString(`<Symbol: ${this.identifier}>`),this.value=t,this.identifier=e,this.isConstant=null!==(s=i.isConstant)&&void 0!==s&&s,this.isAccessible=null===(n=i.isAccessible)||void 0===n||n}}export class Context{constructor(){this.initialisedAsGlobal=!1,this.libs=[],this.deleted=!1,this.symbolTable={}}get parent(){return this.parent_}set parent(t){t!=this?this.parent_=t:console.log("Setting context parent to self".red)}has(t){return void 0!==this.get(t)}hasOwn(t){return this.symbolTable[t]instanceof ESSymbol}get(t){let e=this.getSymbol(t);return e instanceof ESError||null==e?e:e.value}getRawSymbolTableAsDict(){const t={};for(let e in this.symbolTable)t[e]=this.symbolTable[e].value;return t}getSymbolTableAsDict(){const t={};for(let e in this.symbolTable)t[e]=this.symbolTable[e];return t}getSymbol(t){let e=this.symbolTable[t];if(void 0!==e&&!e.isAccessible)return new TypeError(Position.unknown,"assessable","inaccessible",e.identifier);if(void 0===e&&this.parent){let i=this.parent.getSymbol(t);if(i instanceof ESError)return i;e=i}return e}set(t,e,i={}){let s=this;if(i.global)s=this.root;else{for(;!s.hasOwn(t)&&void 0!==s.parent;)s=s.parent;s.hasOwn(t)||(s=this)}return s.setOwn(t,e,i)}setOwn(t,e,i={}){if(e instanceof ESPrimitive||(e=ESPrimitive.wrap(e)),i.global&&!this.initialisedAsGlobal&&(i.global=!1),!i.forceThroughConst){let e=this.symbolTable[t];if(null==e?void 0:e.isConstant)return new TypeError(Position.unknown,"dynamic","constant",t)}this.symbolTable[t]=new ESSymbol(e,t,i)}remove(t){delete this.symbolTable[t]}clear(){for(let t in this.symbolTable)this.remove(t);this.parent=void 0,this.deleted=!0}get root(){let t=this;for(;t.parent;)t=t.parent;return t}resetAsGlobal(){var t,e;if(!this.initialisedAsGlobal)return;const i=this.root.get("print"),s=this.root.get("input");i instanceof ESPrimitive&&s instanceof ESPrimitive?(this.symbolTable={},this.initialisedAsGlobal=!1,initialise(this,(null===(t=i.valueOf())||void 0===t?void 0:t.func)||console.log,(null===(e=s.valueOf())||void 0===e?void 0:e.func)||(()=>{}),this.libs)):console.error("Error with print and input functions.")}clone(){const t=new Context;return t.parent=this.parent,t.deleted=this.deleted,t.initialisedAsGlobal=this.initialisedAsGlobal,t.libs=[...this.libs],t.symbolTable=Object.assign(Object.assign({},t.symbolTable),this.symbolTable),t}deepClone(){var t;console.log("cloning");let e=this.clone();return e.parent=null===(t=e.parent)||void 0===t?void 0:t.deepClone(),e}mergeWith(t){this.root.parent=t.deepClone()}log(){console.log("---- CONTEXT ----");for(let t in this.symbolTable){const e=this.symbolTable[t];let i=t;e.isConstant&&(i+=" (CONST)"),e.isAccessible||(i+=" (INACCESSIBLE)"),i+=": ",i+=str(this.symbolTable[t].value),console.log(i)}console.log("-----------------")}}export function generateESFunctionCallContext(t,e,i){const s=new Context;s.parent=i;let n=Math.max(t.length,e.arguments_.length);for(let i=0;i<n;i++){let n=new ESUndefined,o=types.any;if(null==e.arguments_[i])continue;const l=e.arguments_[i];if(!(l.type instanceof ESType))return new TypeError(Position.unknown,"Type",typeof l.type,l.type);if(t[i]instanceof ESPrimitive&&(o=t[i].__type__,n=t[i]),!l.type.includesType(o))return new TypeError(Position.unknown,l.type.__name__,o.__name__);s.setOwn(l.name,n,{forceThroughConst:!0})}let o=s.setOwn("args",new ESArray(t));return o instanceof ESError?o:s}