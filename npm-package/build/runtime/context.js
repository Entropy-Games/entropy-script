import{initialise}from"../init.js";import{ESError,TypeError,ReferenceError}from"../errors.js";import{Position}from"../position.js";import{ESArray,ESPrimitive,ESString,ESType,ESUndefined,types}from"./primitiveTypes.js";import{str}from"../util/util.js";export class ESSymbol{constructor(e,t,i={}){var n,s;this.clone=()=>new ESSymbol(this.value.clone(),this.identifier,{isConstant:this.isConstant,isAccessible:this.isAccessible}),this.str=()=>new ESString(`<Symbol: ${this.identifier}>`),this.value=e,this.identifier=t,this.isConstant=null!==(n=i.isConstant)&&void 0!==n&&n,this.isAccessible=null===(s=i.isAccessible)||void 0===s||s}}export class Context{constructor(){this.symbolTable={},this.initialisedAsGlobal=!1,this.deleted=!1,this.importPaths=[]}get parent(){return this.parent_}set parent(e){e!=this?this.parent_=e:console.log("Setting context parent to 'this'".red)}has(e){return void 0!==this.get(e)}hasOwn(e){return this.symbolTable[e]instanceof ESSymbol}get(e){let t=this.getSymbol(e);return t instanceof ESError||null==t?t:t.value}getRawSymbolTableAsDict(){const e={};for(let t in this.symbolTable)e[t]=this.symbolTable[t].value;return e}getSymbolTableAsDict(){const e={};for(let t in this.symbolTable)e[t]=this.symbolTable[t];return e}getSymbol(e){let t=this.symbolTable[e];if(void 0!==t&&!t.isAccessible)return new TypeError(Position.unknown,"assessable","inaccessible",t.identifier);if(void 0===t&&this.parent){let i=this.parent.getSymbol(e);if(i instanceof ESError)return i;if(!i)return new ReferenceError(Position.unknown,e);t=i}return t}set(e,t,i={}){let n=this;if(i.global)n=this.root;else{for(;!n.hasOwn(e)&&void 0!==n.parent;)n=n.parent;n.hasOwn(e)||(n=this)}return n.setOwn(e,t,i)}setOwn(e,t,i={}){if(t instanceof ESPrimitive||(t=ESPrimitive.wrap(t)),i.global&&!this.initialisedAsGlobal&&(i.global=!1),!i.forceThroughConst){let t=this.symbolTable[e];if(null==t?void 0:t.isConstant)return new TypeError(Position.unknown,"dynamic","constant",e)}this.symbolTable[e]=new ESSymbol(t,e,i)}remove(e){delete this.symbolTable[e]}clear(){for(let e in this.symbolTable)this.remove(e);this.parent=void 0,this.deleted=!0}get root(){let e=this;for(;e.parent;)e=e.parent;return e}resetAsGlobal(){var e,t;if(!this.initialisedAsGlobal)return;const i=this.root.get("print"),n=this.root.get("input");i instanceof ESPrimitive&&n instanceof ESPrimitive?(this.symbolTable={},this.initialisedAsGlobal=!1,initialise(this,(null===(e=i.valueOf())||void 0===e?void 0:e.func)||console.log,(null===(t=n.valueOf())||void 0===t?void 0:t.func)||(()=>{}))):console.error("Error with print and input functions.")}clone(){const e=new Context;return e.parent=this.parent,e.deleted=this.deleted,e.initialisedAsGlobal=this.initialisedAsGlobal,e.symbolTable=Object.assign(Object.assign({},e.symbolTable),this.symbolTable),e}deepClone(){var e;let t=this.clone();return t.parent=null===(e=t.parent)||void 0===e?void 0:e.deepClone(),t}mergeWith(e){this.root.parent=e.deepClone()}log(){console.log("---- CONTEXT ----");for(let e in this.symbolTable){const t=this.symbolTable[e];let i=e;t.isConstant&&(i+=" (CONST)"),t.isAccessible||(i+=" (INACCESSIBLE)"),i+=": ",i+=str(this.symbolTable[e].value),console.log(i)}console.log("-----------------")}}export function generateESFunctionCallContext(e,t,i){const n=new Context;n.parent=i;let s=Math.max(e.length,t.arguments_.length);for(let o=0;o<s;o++){let s=new ESUndefined,r=types.any;if(!t.arguments_[o])continue;const l=t.arguments_[o];if(!(l.type instanceof ESType))return new TypeError(Position.unknown,"Type",typeof l.type,l.type);if(e[o]instanceof ESPrimitive&&(r=e[o].__type__,s=e[o]),!1===l.type.includesType({context:i},r).valueOf())return new TypeError(Position.unknown,l.type.__name__,r.__name__,str(s));n.setOwn(l.name,s,{forceThroughConst:!0})}let o=n.setOwn("args",new ESArray(e),{forceThroughConst:!0});return o instanceof ESError?o:n}